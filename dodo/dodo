#!/usr/bin/python3
"""Entrypoint for dodo"""

import importlib
import inspect
import os
import pkgutil
import sys
import traceback


def get_modules_from_package(package_obj):
    """Extracts all the modules from <package_obj> using pkgutil and returns
       them. pkgutil.iter_items() returns output in format
          [(FileFinder('/tmp/testdir'), 'best', True),
           (FileFinder('/tmp/testdir'), 'test', False),
           (FileFinder('/tmp/testdir'), 'test1', False)].
       It is a named tuple in format (
            importer, <package-name/module-name>, bool(ispackage)).
    """
    modules = [name for _, name, ispkg in
               pkgutil.iter_modules(package_obj.__path__) if not ispkg]
    return modules


def print_usage():
    """Print usage information"""
    print("dodo is a simple test framework used to write tests for Python \
        application")
    print("dodo <test-directory>")


def get_functions_from_module(module_obj):
    """Extracts all the functions from <module_obj> using introspection API
       and returns them.
       Example of return value of inspect.getmembers is following one.
       [('test1', <function test1 at 0x7f1e2761a7b8>),
        ('test2', <function test2 at 0x7f1e2761a840>)]
    """
    functions = [member for member in
                 inspect.getmembers(module_obj)
                 if inspect.isfunction(member[1])]
    return functions


def main(test_dir):
    """Main function"""
    # TODO: Use Python 3 Path module

    # Get the absolute path of supplied directory in case only directory name
    # is supplied instead of full path
    absolute_path = os.path.abspath(test_dir)

    # Parent directory is a parent directory of a package. i.e In /tmp/testdir,
    # /tmp is a parent directory
    parent_dir = os.path.normpath(os.path.join(absolute_path, ".."))

    # We need to put parent directory of package in PYTHONPATH to import it
    sys.path.append(parent_dir)

    # Get the basename of path. i.e In /tmp/testdir, testdir is a base name
    package_name = os.path.basename(absolute_path)

    # Import package dynamically
    package_instance = importlib.import_module(package_name)

    # Get modules from package
    modules = get_modules_from_package(package_instance)

    # Dictionary with {<module_name>:<[functions]>}
    module_functions = dict()

    # Iterate through all the modules and extract functions from them
    for module in modules:
        tmp = importlib.import_module("{0}.{1}".format(package_name, module))
        functions = get_functions_from_module(tmp)
        function_list = module_functions.get(module, [])
        function_list.extend(functions)
        module_functions[module] = function_list

    # Iterate through <module_functions> dictionary and execute each function
    # for all the modules.
    for module_name, function_list in module_functions.items():
        for function in function_list:
            try:
                # Execute function
                function[1]()
            except Exception as e:
                exc_type, exc_value, exc_tb = sys.exc_info()
                print("".join(
                    (traceback.format_exception(exc_type, exc_value, exc_tb))))


if __name__ == "__main__":
    try:
        if len(sys.argv) < 2:
            print_usage()
            sys.exit(128)

        main(sys.argv[1])
    except Exception as exception:
        print(exception)
